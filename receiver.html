<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
    <style>
        html, body {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            background: #000; overflow: hidden;
        }
        video {
            width: 100%; height: 100%;
            object-fit: contain;
            background: #000;
        }
        #welcome-img {
            display: none;
            position: fixed; top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: contain;
            background: #000;
            z-index: 5;
        }
        #status {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #fff; font: 24px -apple-system, sans-serif;
            text-align: center; opacity: 0;
            transition: opacity 0.4s;
            z-index: 10;
            pointer-events: none;
        }
        #status.visible { opacity: 0.8; }
    </style>
</head>
<body>
    <div id="status">Waiting for stream…</div>
    <img id="welcome-img" />
    <video id="v" autoplay playsinline></video>
    <script>
    'use strict';

    const NS  = 'urn:x-cast:com.screenmirror.stream';
    const TAG = '[SMReceiver]';

    const statusEl   = document.getElementById('status');
    const video      = document.getElementById('v');
    const welcomeImg = document.getElementById('welcome-img');

    const ctx = cast.framework.CastReceiverContext.getInstance();
    const pm  = ctx.getPlayerManager();
    let senderBusId = null;

    function report(msg) {
        console.log(TAG, msg);
        if (senderBusId) {
            try { ctx.sendCustomMessage(NS, senderBusId, {type:'DIAG', msg:msg}); } catch(_){}
        }
    }

    function showStatus(text) {
        statusEl.textContent = text;
        statusEl.classList.add('visible');
    }
    function hideStatus() {
        statusEl.classList.remove('visible');
    }

    ctx.addCustomMessageListener(NS, event => {
        senderBusId = event.senderId;
        const d = event.data;

        if (d.type === 'START_STREAM') {
            report('START_STREAM: ' + d.wsUrl + ' sound=' + d.soundEnabled);
            video.muted = (d.soundEnabled === false);
            try {
                const wsUrl = new URL(d.wsUrl);
                const httpUrl = 'http://' + wsUrl.hostname + ':8080/live.mp4';
                startHTTPStream(httpUrl);
            } catch(e) {
                report('URL parse error: ' + e.message);
                startWSStream(d.wsUrl);
            }
        }
        else if (d.type === 'STOP_STREAM')  { stopAll(); }
        else if (d.type === 'PLAY_HLS') {
            report('PLAY_HLS: ' + d.hlsUrl + ' sound=' + d.soundEnabled);
            video.muted = (d.soundEnabled === false);
            try {
                const hlsUrlObj = new URL(d.hlsUrl);
                const httpUrl = 'http://' + hlsUrlObj.hostname + ':8080/live.mp4';
                startHTTPStream(httpUrl);
            } catch(e) {
                report('PLAY_HLS URL parse error: ' + e.message);
            }
        }
        else if (d.type === 'SHOW_WELCOME') {
            report('SHOW_WELCOME: ' + d.imageUrl);
            showWelcome(d.imageUrl);
        }
        else if (d.type === 'SET_SOUND') {
            report('SET_SOUND: ' + d.enabled);
            video.muted = !d.enabled;
        }
    });

    pm.setMessageInterceptor(cast.framework.messages.MessageType.LOAD, req => {
        try {
            const url = new URL(req.media.contentId);
            const httpUrl = 'http://' + url.hostname + ':8080/live.mp4';
            startHTTPStream(httpUrl);
        } catch(e) { report('LOAD error: ' + e.message); }
        return null;
    });

    const opts = new cast.framework.CastReceiverOptions();
    opts.disableIdleTimeout = true;
    opts.statusText = '';
    opts.customNamespaces = {};
    opts.customNamespaces[NS] = cast.framework.system.MessageType.JSON;
    ctx.start(opts);
    report('Receiver v4 — HTTP chunked fMP4');

    let diagTimer = null;
    let streamStartTime = 0;
    let hasPlayed = false;
    let retryTimer = null;
    let retryCount = 0;
    let currentStreamUrl = null;

    function startHTTPStream(httpUrl) {
        stopAll();
        currentStreamUrl = httpUrl;
        retryCount = 0;

        welcomeImg.style.display = 'none';
        video.style.display = 'block';
        showStatus('Connecting…');

        report('HTTP stream: ' + httpUrl);

        video.src = httpUrl;
        video.load();

        streamStartTime = Date.now();
        startDiagnostics();
    }

    let ws = null;
    let mediaSource = null, sourceBuffer = null;
    let msQueue = [], msAppending = false, initReceived = false;
    let lastInitSeg = null;

    function startWSStream(wsUrl) {
        stopAll();
        currentStreamUrl = wsUrl;
        retryCount = 0;

        welcomeImg.style.display = 'none';
        video.style.display = 'block';
        showStatus('Connecting (WS)…');

        report('Fallback WS+MSE: ' + wsUrl);

        ws = new WebSocket(wsUrl);
        ws.binaryType = 'arraybuffer';

        ws.onopen = () => {
            report('WS connected');
            showStatus('Buffering…');
        };

        ws.onmessage = (evt) => {
            const data = new Uint8Array(evt.data);
            if (!initReceived) {
                initReceived = true;
                lastInitSeg = data;
                report('Init segment: ' + data.length + ' bytes');
                createMSE(data);
                return;
            }
            if (data.length > 7 && data[4]===0x66 && data[5]===0x74 && data[6]===0x79 && data[7]===0x70) {
                lastInitSeg = data;
                report('Re-init: ' + data.length + ' bytes');
                createMSE(data);
                return;
            }
            enqueueMS(data);
        };

        ws.onerror = () => { report('WS error'); };
        ws.onclose = () => {
            report('WS closed');
            if (currentStreamUrl === wsUrl) {
                retryTimer = setTimeout(() => startWSStream(wsUrl), 500);
            }
        };

        streamStartTime = Date.now();
        startDiagnostics();
    }

    function createMSE(initSeg) {
        if (mediaSource && mediaSource.readyState === 'open') {
            try { mediaSource.endOfStream(); } catch(_){}
        }
        mediaSource = null;
        sourceBuffer = null;
        msQueue = [];
        msAppending = false;

        mediaSource = new MediaSource();
        mediaSource.addEventListener('sourceopen', () => {
            try {
                sourceBuffer = mediaSource.addSourceBuffer('video/mp4; codecs="avc1.640029,mp4a.40.2"');
            } catch(e) {
                try {
                    sourceBuffer = mediaSource.addSourceBuffer('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
                } catch(e2) {
                    report('addSourceBuffer failed: ' + e2.message);
                    return;
                }
            }
            sourceBuffer.mode = 'sequence';
            sourceBuffer.addEventListener('updateend', () => {
                msAppending = false;
                drainMS();
            });
            msQueue.unshift(initSeg);
            drainMS();
        });
        video.src = URL.createObjectURL(mediaSource);
    }

    function enqueueMS(data) {
        if (msQueue.length > 10) msQueue.splice(0, msQueue.length - 5);
        msQueue.push(data);
        drainMS();
    }

    function drainMS() {
        if (msAppending || !sourceBuffer || msQueue.length === 0) return;
        if (sourceBuffer.updating) return;
        if (!mediaSource || mediaSource.readyState !== 'open') return;
        msAppending = true;
        try {
            sourceBuffer.appendBuffer(msQueue.shift());
        } catch(e) {
            msAppending = false;
            report('appendBuffer error: ' + e.name);
        }
    }

    function showWelcome(imageUrl) {
        stopAll();
        welcomeImg.src = imageUrl;
        welcomeImg.style.display = 'block';
        video.style.display = 'none';
        hideStatus();
    }

    function stopAll() {
        currentStreamUrl = null;
        if (retryTimer) { clearTimeout(retryTimer); retryTimer = null; }
        if (diagTimer) { clearInterval(diagTimer); diagTimer = null; }

        video.pause();
        video.removeAttribute('src');
        video.load();

        if (ws) { ws.onclose = null; ws.onerror = null; ws.close(); ws = null; }

        if (mediaSource && mediaSource.readyState === 'open') {
            try { mediaSource.endOfStream(); } catch(_){}
        }
        mediaSource = null;
        sourceBuffer = null;
        msQueue = [];
        msAppending = false;
        initReceived = false;
        lastInitSeg = null;
        hasPlayed = false;
    }

    video.addEventListener('loadedmetadata', () => {
        report('loadedmetadata: dur=' + video.duration + ' rs=' + video.readyState);
    });

    video.addEventListener('canplay', () => {
        report('canplay: rs=' + video.readyState + ' muted=' + video.muted);
        if (!hasPlayed) {
            video.play().then(() => {
                hasPlayed = true;
                hideStatus();
                report('PLAYING');
            }).catch(e => {
                report('play() err: ' + (e ? e.name : '?') + ' — trying muted');
                video.muted = true;
                video.play().then(() => {
                    hasPlayed = true;
                    hideStatus();
                    report('PLAYING (muted)');
                }).catch(() => {});
            });
        }
    });

    video.addEventListener('playing', () => {
        hideStatus();
        hasPlayed = true;
    });

    video.addEventListener('waiting', () => {
        report('waiting: ct=' + video.currentTime.toFixed(2) + ' rs=' + video.readyState);
    });

    video.addEventListener('stalled', () => {
        report('stalled: ct=' + video.currentTime.toFixed(2));
    });

    video.addEventListener('error', () => {
        const err = video.error;
        report('video error: code=' + (err ? err.code + ' ' + (err.message || '') : '?'));
        if (currentStreamUrl && retryCount < 10) {
            const url = currentStreamUrl;
            const delay = Math.min(500 * (retryCount + 1), 3000);
            retryCount++;
            report('Retry #' + retryCount + ' in ' + delay + 'ms');
            retryTimer = setTimeout(() => {
                if (url.startsWith('http')) {
                    startHTTPStream(url);
                } else {
                    startWSStream(url);
                }
            }, delay);
        }
    });

    function startDiagnostics() {
        if (diagTimer) clearInterval(diagTimer);
        diagTimer = setInterval(() => {
            const elapsed = ((Date.now() - streamStartTime) / 1000).toFixed(1);
            const ct = video.currentTime.toFixed(2);
            const paused = video.paused ? 'PAUSED' : 'playing';
            const muted = video.muted ? 'muted' : 'unmuted';
            const rs = video.readyState;
            const nw = video.networkState;

            let bufInfo = 'none';
            if (video.buffered.length > 0) {
                const bs = video.buffered.start(0).toFixed(2);
                const be = video.buffered.end(video.buffered.length - 1).toFixed(2);
                bufInfo = bs + '-' + be;
            }

            let dropInfo = '';
            if (video.getVideoPlaybackQuality) {
                const q = video.getVideoPlaybackQuality();
                dropInfo = ' drop=' + q.droppedVideoFrames + '/' + q.totalVideoFrames;
            }

            report('DIAG t=' + elapsed + 's ct=' + ct + ' ' + paused + ' ' + muted
                + ' rs=' + rs + ' nw=' + nw + ' buf=[' + bufInfo + ']' + dropInfo);
        }, 5000);
    }
    </script>
</body>
</html>
