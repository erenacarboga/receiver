<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
    <style>
        html, body {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            background: #000; overflow: hidden;
        }
        video {
            width: 100%; height: 100%;
            object-fit: contain;
            background: #000;
        }
        #welcome-img {
            display: none;
            position: fixed; top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: contain;
            background: #000;
            z-index: 5;
        }
        #status {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #fff; font: 24px -apple-system, sans-serif;
            text-align: center; opacity: 0;
            transition: opacity 0.4s;
            z-index: 10;
            pointer-events: none;
        }
        #status.visible { opacity: 0.8; }
    </style>
</head>
<body>
    <div id="status">Waiting for stream…</div>
    <img id="welcome-img" />
    <video id="v" autoplay playsinline></video>
    <script>
    'use strict';

    const NS  = 'urn:x-cast:com.screenmirror.stream';
    const TAG = '[SMReceiver]';

    const statusEl   = document.getElementById('status');
    const video      = document.getElementById('v');
    const welcomeImg = document.getElementById('welcome-img');

    const ctx = cast.framework.CastReceiverContext.getInstance();
    const pm  = ctx.getPlayerManager();
    let senderBusId = null;

    function report(msg) {
        console.log(TAG, msg);
        if (senderBusId) {
            try { ctx.sendCustomMessage(NS, senderBusId, {type:'DIAG', msg:msg}); } catch(_){}
        }
    }

    function showStatus(text) {
        statusEl.textContent = text;
        statusEl.classList.add('visible');
    }
    function hideStatus() {
        statusEl.classList.remove('visible');
    }

    ctx.addCustomMessageListener(NS, event => {
        senderBusId = event.senderId;
        const d = event.data;
        if (d.type === 'START_STREAM')       {
            report('START_STREAM: ' + d.wsUrl + ' sound=' + d.soundEnabled);
            if (d.soundEnabled === false) {
                video.muted = true;
            } else {
                video.muted = false;
            }
            startStream(d.wsUrl);
        }
        else if (d.type === 'STOP_STREAM')   { stopStream(); }
        else if (d.type === 'SHOW_WELCOME')  { report('SHOW_WELCOME: ' + d.imageUrl); showWelcome(d.imageUrl); }
        else if (d.type === 'SET_SOUND')     {
            report('SET_SOUND: ' + d.enabled);
            video.muted = !d.enabled;
        }
    });

    pm.setMessageInterceptor(cast.framework.messages.MessageType.LOAD, req => {
        try {
            const url = new URL(req.media.contentId);
            startStream('ws://' + url.hostname + ':8082/stream');
        } catch(e) { report('LOAD error: ' + e.message); }
        return null;
    });

    const opts = new cast.framework.CastReceiverOptions();
    opts.disableIdleTimeout = true;
    opts.statusText = '';
    opts.customNamespaces = {};
    opts.customNamespaces[NS] = cast.framework.system.MessageType.JSON;
    ctx.start(opts);
    report('Receiver v3 started');

    let ws = null;
    let mediaSource = null, sourceBuffer = null;
    let queue = [], appending = false, initReceived = false;
    let lastInitSeg = null;
    let hasPlayed = false;
    let statusTimer = null;

    const LATENCY_CHECK_MS    = 200;
    const MAX_DRIFT_SEC       = 0.8;
    const TRIM_INTERVAL_MS    = 2000;
    const TRIM_KEEP_BEHIND    = 2.0;
    const STALL_TIMEOUT_MS    = 5000;
    const REINIT_COOLDOWN_MS  = 3000;
    const QUEUE_MAX           = 30;
    const SEEK_BEHIND         = 0.15;
    const WAITING_THROTTLE_MS = 500;

    let lastProgressTime = 0, lastProgressCT = -1;
    let lastTrimTime = 0, lastReinitTime = 0;
    let latencyTimer = null;
    let appendErrorCount = 0;
    let lastWaitingSeek = 0;
    let playPending = false;
    let diagTimer = null;
    let totalBytesReceived = 0;
    let fragmentsReceived = 0;
    let streamStartTime = 0;
    let lastDiagTime = 0;
    let lastDroppedFrames = 0;
    let lastTotalFrames = 0;
    let seekCount = 0;
    let waitingCount = 0;

    function showWelcome(imageUrl) {
        stopStream();
        welcomeImg.src = imageUrl;
        welcomeImg.style.display = 'block';
        video.style.display = 'none';
        hideStatus();
    }

    function startStream(wsUrl) {
        welcomeImg.style.display = 'none';
        video.style.display = 'block';
        showStatus('Connecting…');
        stopStream();

        ws = new WebSocket(wsUrl);
        ws.binaryType = 'arraybuffer';

        ws.onopen = () => {
            report('WebSocket connected');
            showStatus('Buffering…');
        };

        ws.onmessage = (evt) => {
            const data = new Uint8Array(evt.data);

            if (!initReceived) {
                initReceived = true;
                lastInitSeg = data;
                report('Init segment: ' + data.length + ' bytes');
                createMSE(data);
                return;
            }

            if (data.length > 7 && data[4]===0x66 && data[5]===0x74 && data[6]===0x79 && data[7]===0x70) {
                lastInitSeg = data;
                report('Re-init (resolution change): ' + data.length + ' bytes');
                reinitMSE();
                return;
            }
            totalBytesReceived += data.length;
            fragmentsReceived++;
            enqueue(data);
        };

        ws.onerror = () => {
            report('WS error');
            showStatus('Connection error');
        };

        ws.onclose = () => {
            report('WS closed');
            const url = wsUrl;
            setTimeout(() => {
                if (!ws || ws.readyState === WebSocket.CLOSED) {
                    initReceived = false;
                    startStream(url);
                }
            }, 300);
        };
    }

    function stopStream() {
        if (latencyTimer) { clearInterval(latencyTimer); latencyTimer = null; }
        if (statusTimer)  { clearInterval(statusTimer);  statusTimer = null; }
        if (ws) { ws.onclose = null; ws.onerror = null; ws.close(); ws = null; }

        if (mediaSource && mediaSource.readyState === 'open') {
            try { mediaSource.endOfStream(); } catch(_){}
        }
        mediaSource = null;
        sourceBuffer = null;
        queue = [];
        appending = false;
        initReceived = false;
        hasPlayed = false;
        lastProgressCT = -1;
        lastProgressTime = 0;
        appendErrorCount = 0;
        playPending = false;
        if (diagTimer) { clearInterval(diagTimer); diagTimer = null; }
        totalBytesReceived = 0;
        fragmentsReceived = 0;
        seekCount = 0;
        waitingCount = 0;
        lastDroppedFrames = 0;
        lastTotalFrames = 0;
    }

    function createMSE(initSeg) {
        mediaSource = new MediaSource();
        appendErrorCount = 0;

        mediaSource.addEventListener('sourceopen', () => {
            report('MSE sourceopen');
            const codec = detectCodec(initSeg) || 'avc1.640029,mp4a.40.2';
            report('Codec: ' + codec);

            try {
                sourceBuffer = mediaSource.addSourceBuffer('video/mp4; codecs="' + codec + '"');
            } catch(e) {
                report('addSourceBuffer failed: ' + e.message + ' — trying baseline muxed');
                try {
                    sourceBuffer = mediaSource.addSourceBuffer('video/mp4; codecs="avc1.42E01E,mp4a.40.2"');
                } catch(e2) {
                    report('Baseline muxed also failed: ' + e2.message + ' — trying video-only');
                    try {
                        sourceBuffer = mediaSource.addSourceBuffer('video/mp4; codecs="avc1.42E01E"');
                    } catch(e3) {
                        report('All codec attempts failed');
                        return;
                    }
                }
            }

            sourceBuffer.mode = 'sequence';
            sourceBuffer.addEventListener('updateend', onUpdateEnd);
            sourceBuffer.addEventListener('error', () => {
                report('SourceBuffer error');
                queue = [];
                appending = false;
                reinitMSE();
            });

            queue.unshift(initSeg);
            drainQueue();

            startLatencyController();
            startDiagnostics();

            statusTimer = setInterval(() => {
                attemptPlay();
                if (hasPlayed && statusTimer) {
                    clearInterval(statusTimer);
                    statusTimer = null;
                }
            }, 100);
        });

        mediaSource.addEventListener('sourceended', () => report('MSE sourceended'));
        mediaSource.addEventListener('sourceclose', () => report('MSE sourceclose'));

        video.src = URL.createObjectURL(mediaSource);
        report('video.src set, waiting for sourceopen…');
    }

    function reinitMSE() {
        const now = Date.now();
        if (now - lastReinitTime < REINIT_COOLDOWN_MS) return;
        lastReinitTime = now;

        report('reinitMSE');

        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send('FORCE_KEYFRAME');
        }

        if (latencyTimer) { clearInterval(latencyTimer); latencyTimer = null; }
        if (statusTimer)  { clearInterval(statusTimer);  statusTimer = null; }
        if (mediaSource && mediaSource.readyState === 'open') {
            try { mediaSource.endOfStream(); } catch(_){}
        }
        mediaSource = null;
        sourceBuffer = null;
        queue = [];
        appending = false;
        hasPlayed = false;
        lastProgressCT = -1;

        if (lastInitSeg) {
            createMSE(lastInitSeg);
        }
    }

    function enqueue(data) {
        if (queue.length >= QUEUE_MAX) {
            const drop = queue.length - Math.floor(QUEUE_MAX / 2);
            queue.splice(0, drop);
            report('Dropped ' + drop + ' queued fragments');
        }
        queue.push(data);
        drainQueue();
    }

    function drainQueue() {
        if (appending || !sourceBuffer || queue.length === 0) return;
        if (sourceBuffer.updating) return;
        if (!mediaSource || mediaSource.readyState !== 'open') {
            queue = [];
            return;
        }
        appending = true;
        const chunk = queue.shift();
        try {
            sourceBuffer.appendBuffer(chunk);
            appendErrorCount = 0;
        } catch(e) {
            appending = false;
            if (appendErrorCount < 5) {
                report('appendBuffer error: ' + e.name);
            } else if (appendErrorCount === 5) {
                report('appendBuffer errors suppressed (' + appendErrorCount + '+)');
            }
            appendErrorCount++;
            if (e.name === 'QuotaExceededError') {
                emergencyTrim();
            } else if (e.name === 'InvalidStateError') {
                queue = [];
            }
        }
    }

    function onUpdateEnd() {
        appending = false;
        if (!hasPlayed && sourceBuffer && sourceBuffer.buffered.length > 0) {
            attemptPlay();
        }
        drainQueue();
    }

    function attemptPlay() {
        if (hasPlayed || playPending || !sourceBuffer || sourceBuffer.buffered.length === 0) return;

        const edge = sourceBuffer.buffered.end(sourceBuffer.buffered.length - 1);
        const start = sourceBuffer.buffered.start(0);
        if (edge - start < 0.03) return;

        playPending = true;
        report('attemptPlay: buf=' + start.toFixed(3) + '-' + edge.toFixed(3)
            + ' muted=' + video.muted + ' rs=' + video.readyState);

        video.play().then(() => {
            playPending = false;
            hasPlayed = true;
            hideStatus();
            report('PLAYING time=' + video.currentTime.toFixed(3));
        }).catch(e => {
            playPending = false;
            report('play() error: ' + (e ? e.name + ' ' + (e.message || '') : 'unknown'));
            if (!video.muted) {
                playPending = true;
                video.muted = true;
                video.play().then(() => {
                    playPending = false;
                    hasPlayed = true;
                    hideStatus();
                    video.muted = false;
                    report('PLAYING (muted-workaround) time=' + video.currentTime.toFixed(3));
                }).catch(() => { playPending = false; });
            }
        });
    }

    function startLatencyController() {
        lastProgressTime = Date.now();
        lastProgressCT = -1;

        latencyTimer = setInterval(() => {
            if (!sourceBuffer || sourceBuffer.buffered.length === 0) return;
            if (video.paused && hasPlayed) {
                video.play().catch(() => {});
            }
            if (video.paused) return;

            const now = Date.now();
            const ct  = video.currentTime;
            const edge = sourceBuffer.buffered.end(sourceBuffer.buffered.length - 1);

            const drift = edge - ct;
            if (drift > MAX_DRIFT_SEC) {
                video.currentTime = edge - SEEK_BEHIND;
            }

            if (Math.abs(ct - lastProgressCT) > 0.005) {
                lastProgressTime = now;
                lastProgressCT = ct;
            } else {
                const stuckFor = now - lastProgressTime;
                const hasDataAhead = (edge - ct) > 0.1;
                if (stuckFor > STALL_TIMEOUT_MS && hasDataAhead) {
                    report('Stall: ' + ct.toFixed(2) + 's for ' + (stuckFor/1000).toFixed(1) + 's — reinit');
                    lastProgressCT = -1;
                    reinitMSE();
                    return;
                }
            }

            if (now - lastTrimTime > TRIM_INTERVAL_MS && !sourceBuffer.updating) {
                const removeEnd = ct - TRIM_KEEP_BEHIND;
                const bufStart = sourceBuffer.buffered.start(0);
                if (removeEnd > bufStart + 0.1) {
                    try {
                        sourceBuffer.remove(bufStart, removeEnd);
                        lastTrimTime = now;
                    } catch(_) {}
                }
            }

            if (sourceBuffer.buffered.length > 4) {
                report('Fragmented buffer (' + sourceBuffer.buffered.length + ' ranges) — reinit');
                reinitMSE();
            }
        }, LATENCY_CHECK_MS);
    }

    function emergencyTrim() {
        if (!sourceBuffer || sourceBuffer.buffered.length === 0) return;
        try {
            const start = sourceBuffer.buffered.start(0);
            const end = Math.max(start, video.currentTime - 0.5);
            if (end > start) sourceBuffer.remove(start, end);
        } catch(_) {}
    }

    video.addEventListener('waiting', () => {
        if (!hasPlayed || !sourceBuffer || sourceBuffer.buffered.length === 0) return;
        const now = Date.now();
        if (now - lastWaitingSeek < WAITING_THROTTLE_MS) return;
        const edge = sourceBuffer.buffered.end(sourceBuffer.buffered.length - 1);
        if (edge - video.currentTime > 0.1) {
            video.currentTime = edge - SEEK_BEHIND;
            lastWaitingSeek = now;
            seekCount++;
            waitingCount++;
            report('waiting → seek to edge ' + edge.toFixed(3));
        }
    });

    video.addEventListener('stalled', () => {
        if (!sourceBuffer || sourceBuffer.buffered.length === 0) return;
        const now = Date.now();
        if (now - lastWaitingSeek < WAITING_THROTTLE_MS) return;
        const edge = sourceBuffer.buffered.end(sourceBuffer.buffered.length - 1);
        if (edge - video.currentTime > 0.1) {
            video.currentTime = edge - SEEK_BEHIND;
            lastWaitingSeek = now;
        }
    });

    video.addEventListener('error', () => {
        const err = video.error;
        report('video error: code=' + (err ? err.code : '?'));
        if (lastInitSeg) reinitMSE();
    });

    video.addEventListener('canplay', () => {
        report('canplay event: hasPlayed=' + hasPlayed + ' rs=' + video.readyState + ' muted=' + video.muted);
        if (!hasPlayed) {
            video.play().then(() => {
                hasPlayed = true;
                hideStatus();
                report('PLAYING via canplay');
            }).catch(e => {
                report('canplay play() error: ' + (e ? e.name + ' ' + (e.message || '') : 'unknown'));
            });
        }
    });

    video.addEventListener('playing', () => hideStatus());
    video.addEventListener('timeupdate', () => { if (hasPlayed) hideStatus(); });

    function startDiagnostics() {
        if (diagTimer) clearInterval(diagTimer);
        streamStartTime = Date.now();
        lastDiagTime = streamStartTime;
        diagTimer = setInterval(() => {
            if (!sourceBuffer) return;
            const now = Date.now();
            const elapsed = ((now - streamStartTime) / 1000).toFixed(1);
            const ct = video.currentTime.toFixed(2);
            const paused = video.paused ? 'PAUSED' : 'playing';
            const muted = video.muted ? 'muted' : 'unmuted';
            const rs = video.readyState;

            let bufInfo = 'none';
            if (sourceBuffer.buffered.length > 0) {
                const bs = sourceBuffer.buffered.start(0).toFixed(2);
                const be = sourceBuffer.buffered.end(sourceBuffer.buffered.length - 1).toFixed(2);
                bufInfo = bs + '-' + be + ' (' + sourceBuffer.buffered.length + ' ranges)';
            }

            let dropInfo = 'N/A';
            if (video.getVideoPlaybackQuality) {
                const q = video.getVideoPlaybackQuality();
                const newDropped = q.droppedVideoFrames - lastDroppedFrames;
                const newTotal = q.totalVideoFrames - lastTotalFrames;
                const dropRate = newTotal > 0 ? ((newDropped / newTotal) * 100).toFixed(1) : '0.0';
                dropInfo = 'dropped=' + q.droppedVideoFrames + '/' + q.totalVideoFrames
                    + ' (period: ' + newDropped + '/' + newTotal + ' = ' + dropRate + '%)';
                lastDroppedFrames = q.droppedVideoFrames;
                lastTotalFrames = q.totalVideoFrames;
            }

            const kbps = ((totalBytesReceived * 8) / ((now - streamStartTime) / 1000) / 1000).toFixed(0);

            report('DIAG t=' + elapsed + 's ct=' + ct + ' ' + paused + ' ' + muted
                + ' rs=' + rs + ' buf=[' + bufInfo + '] q=' + queue.length
                + ' frags=' + fragmentsReceived + ' ' + kbps + 'kbps'
                + ' seeks=' + seekCount + ' waits=' + waitingCount
                + ' | ' + dropInfo);
        }, 5000);
    }

    function detectCodec(d) {
        let videoCodec = null;
        let hasAudio = false;
        for (let i = 0; i < d.length - 4; i++) {
            if (!videoCodec && i + 7 < d.length &&
                d[i]===0x61 && d[i+1]===0x76 && d[i+2]===0x63 && d[i+3]===0x43) {
                if (d[i+4] === 1) {
                    const h = n => n.toString(16).padStart(2, '0');
                    videoCodec = 'avc1.' + h(d[i+5]) + h(d[i+6]) + h(d[i+7]);
                }
            }
            if (d[i]===0x6D && d[i+1]===0x70 && d[i+2]===0x34 && d[i+3]===0x61) {
                hasAudio = true;
            }
            if (d[i]===0x65 && d[i+1]===0x73 && d[i+2]===0x64 && d[i+3]===0x73) {
                hasAudio = true;
            }
        }
        if (videoCodec && hasAudio) {
            return videoCodec + ',mp4a.40.2';
        }
        if (videoCodec && d.length > 800) {
            return videoCodec + ',mp4a.40.2';
        }
        return videoCodec;
    }
    </script>
</body>
</html>
