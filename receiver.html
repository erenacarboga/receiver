<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<!--
  receiver.html — Chromecast Custom Receiver (WebRTC Video Track)

  Architecture:
    Phone → WebRTC PeerConnection (video track / RTP) → This receiver
    pc.ontrack → video.srcObject = stream   ← NO MSE, NO SourceBuffer!

  WebRTC handles all buffering, jitter compensation, and congestion control.
  Typical end-to-end latency: 50-150 ms (vs 300-800 ms with DataChannel+MSE).
-->
<script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
<style>
html, body {
    margin: 0; padding: 0;
    width: 100%; height: 100%;
    background: #000; overflow: hidden;
}
video {
    width: 100%; height: 100%;
    object-fit: contain;
    background: #000;
}
#welcome-img {
    display: none;
    position: fixed; top: 0; left: 0;
    width: 100%; height: 100%;
    object-fit: contain;
    background: #000;
    z-index: 5;
}
#status {
    position: fixed; top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    color: #fff; font: 24px -apple-system, sans-serif;
    text-align: center;
    display: none;
    z-index: 10;
}
</style>
</head>
<body>
<img id="welcome-img" />
<video id="video" autoplay playsinline muted></video>
<div id="status"></div>

<script>
'use strict';

// ── Constants ───────────────────────────────────────────────
const NS    = 'urn:x-cast:com.screenmirror.stream';
const ctx   = cast.framework.CastReceiverContext.getInstance();
const video = document.getElementById('video');
const welc  = document.getElementById('welcome-img');
const stat  = document.getElementById('status');

let pc        = null;   // RTCPeerConnection
let startTime = 0;
let diagTimer = null;
let senderID  = null;   // who sent the offer

// ── Helpers ─────────────────────────────────────────────────
function log(msg) { console.log('[RECV] ' + msg); }

function showStatus(text) {
    stat.textContent = text;
    stat.style.display = text ? 'block' : 'none';
}

function send(obj) {
    if (!senderID) return;
    try {
        ctx.sendCustomMessage(NS, senderID, JSON.stringify(obj));
    } catch (e) {
        log('sendCustomMessage error: ' + e);
    }
}

// ── Cast Message Handler ────────────────────────────────────
ctx.addCustomMessageListener(NS, function(event) {
    var msg;
    try {
        msg = typeof event.data === 'string'
            ? JSON.parse(event.data) : event.data;
    } catch (e) {
        log('Bad JSON: ' + e);
        return;
    }

    switch (msg.type) {
        case 'WEBRTC_OFFER':
            senderID = event.senderId;
            handleOffer(msg.sdp);
            break;

        case 'WEBRTC_ICE':
            handleIce(msg);
            break;

        case 'STOP_STREAM':
            stopStream();
            break;

        case 'SHOW_WELCOME':
            showWelcome(msg);
            break;

        case 'SET_SOUND':
            video.muted = !msg.enabled;
            log('Sound ' + (msg.enabled ? 'ON' : 'OFF'));
            break;
    }
});

// ── WebRTC Offer → Answer ───────────────────────────────────
function handleOffer(sdp) {
    log('Offer received (' + sdp.length + ' chars)');

    // Tear down previous session
    stopStream();

    startTime = Date.now();
    welc.style.display = 'none';
    showStatus('Connecting…');

    // Create PeerConnection
    pc = new RTCPeerConnection({
        iceServers: [
            { urls: 'stun:stun.l.google.com:19302' },
            { urls: 'stun:stun1.l.google.com:19302' }
        ]
    });

    // ── Track arrives → play on <video> ──────────────────
    pc.ontrack = function(event) {
        log('Track: ' + event.track.kind +
            ' (streams=' + event.streams.length + ')');

        if (event.streams && event.streams[0]) {
            video.srcObject = event.streams[0];
        } else {
            // Fallback: create new MediaStream
            var ms = new MediaStream();
            ms.addTrack(event.track);
            video.srcObject = ms;
        }

        video.play().then(function() {
            log('Playback started');
            showStatus('');
        }).catch(function(e) {
            log('play() error: ' + e);
            // Retry muted
            video.muted = true;
            video.play().catch(function(e2) {
                log('play() muted retry error: ' + e2);
            });
            showStatus('');
        });
    };

    // ── ICE candidates → send to phone ───────────────────
    pc.onicecandidate = function(event) {
        if (event.candidate) {
            send({
                type: 'WEBRTC_ICE',
                sdpMid: event.candidate.sdpMid,
                sdpMLineIndex: event.candidate.sdpMLineIndex,
                candidate: event.candidate.candidate
            });
        }
    };

    // ── ICE state tracking ───────────────────────────────
    pc.oniceconnectionstatechange = function() {
        log('ICE: ' + pc.iceConnectionState);
        if (pc.iceConnectionState === 'connected' ||
            pc.iceConnectionState === 'completed') {
            showStatus('');
            startDiag();
        } else if (pc.iceConnectionState === 'failed') {
            showStatus('Connection failed');
            send({ type: 'DIAG', data: 'ice=failed' });
        } else if (pc.iceConnectionState === 'disconnected') {
            showStatus('Reconnecting…');
        }
    };

    pc.onconnectionstatechange = function() {
        log('Connection: ' + pc.connectionState);
    };

    // ── Apply offer → create answer → send back ─────────
    pc.setRemoteDescription({ type: 'offer', sdp: sdp })
    .then(function() {
        log('Remote description set');
        return pc.createAnswer();
    })
    .then(function(answer) {
        log('Answer created');
        return pc.setLocalDescription(answer);
    })
    .then(function() {
        send({
            type: 'WEBRTC_ANSWER',
            sdp: pc.localDescription.sdp
        });
        log('Answer sent (' + pc.localDescription.sdp.length +
            ' chars)');
    })
    .catch(function(err) {
        log('SDP negotiation error: ' + err);
        showStatus('Negotiation error');
        send({
            type: 'DIAG',
            data: 'sdp_error=' + err.toString().substring(0, 200)
        });
    });
}

// ── Remote ICE Candidate ────────────────────────────────────
function handleIce(msg) {
    if (!pc) return;
    pc.addIceCandidate({
        sdpMid: msg.sdpMid,
        sdpMLineIndex: msg.sdpMLineIndex,
        candidate: msg.candidate
    }).catch(function(e) {
        log('addIceCandidate error: ' + e);
    });
}

// ── Stop / Cleanup ──────────────────────────────────────────
function stopStream() {
    if (diagTimer) { clearInterval(diagTimer); diagTimer = null; }
    if (pc) {
        pc.close();
        pc = null;
    }
    video.srcObject = null;
    showStatus('');
    log('Stream stopped');
}

// ── Welcome Image ───────────────────────────────────────────
function showWelcome(msg) {
    if (msg.imageURL) {
        welc.src = msg.imageURL;
        welc.onload = function() { welc.style.display = 'block'; };
        welc.onerror = function() { welc.style.display = 'none'; };
    }
    // Hide video while showing welcome
    video.srcObject = null;
    showStatus('');
}

// ── Diagnostics (WebRTC Stats) ──────────────────────────────
function startDiag() {
    if (diagTimer) clearInterval(diagTimer);

    diagTimer = setInterval(function() {
        if (!pc) return;
        var elapsed = ((Date.now() - startTime) / 1000).toFixed(1);

        pc.getStats().then(function(stats) {
            var dec = 0, drop = 0, bytes = 0, jitter = 0;
            var rtt = 0, width = 0, height = 0, fps = 0;
            var codec = '';

            stats.forEach(function(r) {
                if (r.type === 'inbound-rtp' && r.kind === 'video') {
                    dec   = r.framesDecoded  || 0;
                    drop  = r.framesDropped  || 0;
                    bytes = r.bytesReceived  || 0;
                    jitter = r.jitter        || 0;
                    fps   = r.framesPerSecond || 0;
                    if (r.frameWidth)  width  = r.frameWidth;
                    if (r.frameHeight) height = r.frameHeight;
                }
                if (r.type === 'candidate-pair' && r.state === 'succeeded') {
                    rtt = r.currentRoundTripTime || 0;
                }
                if (r.type === 'codec' && r.mimeType) {
                    codec = r.mimeType;
                }
            });

            var diag = 't=' + elapsed + 's' +
                ' ice=' + pc.iceConnectionState +
                ' dec=' + dec +
                ' drop=' + drop +
                ' fps=' + fps +
                ' ' + width + 'x' + height +
                ' jitter=' + (jitter * 1000).toFixed(1) + 'ms' +
                ' rtt=' + (rtt * 1000).toFixed(0) + 'ms' +
                ' bytes=' + bytes +
                (codec ? ' codec=' + codec : '');

            log('[DIAG] ' + diag);

            send({ type: 'DIAG', data: diag });
        }).catch(function(e) {
            log('getStats error: ' + e);
        });
    }, 5000);
}

// ── Start Cast Receiver ─────────────────────────────────────
ctx.start();
log('Receiver ready (WebRTC Video Track)');
</script>
</body>
</html>
