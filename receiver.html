<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
    <style>
        html, body {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            background: #000; overflow: hidden;
        }
        video { width: 100%; height: 100%; object-fit: contain; background: #000; }
        #welcome-img {
            display: none;
            position: fixed; top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: contain;
            background: #000;
            z-index: 5;
        }
        #status {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #fff; font: 24px -apple-system, sans-serif;
            text-align: center; opacity: 0.8;
            transition: opacity 0.5s;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="status">Waiting for stream...</div>
    <img id="welcome-img" />
    <video id="v" autoplay muted playsinline></video>
    <script>
    const TAG = '[SMReceiver]';
    const NS = 'urn:x-cast:com.screenmirror.stream';
    const statusEl = document.getElementById('status');
    const video = document.getElementById('v');
    const welcomeImg = document.getElementById('welcome-img');

    const ctx = cast.framework.CastReceiverContext.getInstance();
    const pm = ctx.getPlayerManager();
    let senderBusId = null;

    function report(msg) {
        console.log(TAG, msg);
        if (senderBusId) {
            try {
                ctx.sendCustomMessage(NS, senderBusId, {type: 'DIAG', msg: msg});
            } catch(e) {}
        }
    }

    function setStatus(text, visible) {
        if (typeof text === 'string') {
            statusEl.textContent = text;
        }
        statusEl.style.opacity = visible ? '0.8' : '0';
        statusEl.style.display = visible ? 'block' : 'none';
    }

    function hideStatusIfRendering() {
        if (video.readyState >= 2 || !video.paused) {
            setStatus(null, false);
        }
    }

    ctx.addCustomMessageListener(NS, event => {
        senderBusId = event.senderId;
        console.log(TAG, 'Custom message from', event.senderId, ':', JSON.stringify(event.data));
        if (event.data.type === 'START_STREAM') {
            report('START_STREAM received: ' + event.data.wsUrl);
            startWebSocketStream(event.data.wsUrl);
        } else if (event.data.type === 'STOP_STREAM') {
            stopStream();
        } else if (event.data.type === 'SHOW_WELCOME') {
            report('SHOW_WELCOME: ' + event.data.imageUrl);
            showWelcome(event.data.imageUrl);
        }
    });

    pm.setMessageInterceptor(
        cast.framework.messages.MessageType.LOAD,
        loadRequest => {
            try {
                const hlsUrl = loadRequest.media.contentId;
                report('LOAD intercepted: ' + hlsUrl);
                const url = new URL(hlsUrl);
                const wsUrl = 'ws://' + url.hostname + ':8082/stream';
                startWebSocketStream(wsUrl);
            } catch (e) {
                report('LOAD intercept error: ' + e.message);
            }
            return null;
        }
    );

    const opts = new cast.framework.CastReceiverOptions();
    opts.disableIdleTimeout = true;
    opts.statusText = '';
    opts.customNamespaces = {};
    opts.customNamespaces[NS] = cast.framework.system.MessageType.JSON;
    ctx.start(opts);
    console.log(TAG, 'Receiver v2 started');

    let ws = null, mediaSource = null, sourceBuffer = null;
    let bufferQueue = [], isAppending = false, initReceived = false;
    let hasPlayed = false, appendCount = 0, firstFragmentDTS = -1;
    let playRetryTimer = null, fatalError = false;
    let lastTrimMs = 0, lastWaitingRecoveryMs = 0;
    let recentWaitingCount = 0, lastControlTickMs = 0;
    let driftEwma = 0.0, activeProfile = 'aggressive';
    let playInFlight = false, lastPlayAttemptMs = 0, lastPlayRejectLogMs = 0;
    let lastProgressTime = 0, lastProgressCT = -1;
    let lastInitSeg = null;
    let lastReinitMs = 0;
    const REINIT_COOLDOWN_MS = 4000;

    const PROFILES = {
        aggressive: {
            startBuffer: 0.15,
            startBehindEdge: 0.06,
            hardSeekDrift: 0.50,
            gentleDrift: 0.15,
            gentleRate: 1.04,
            trimTotalBuffer: 5.0,
            trimBackBuffer: 3.0,
            trimKeepBehind: 2.0,
            waitRecoverDrift: 0.15,
            waitRecoverBehindEdge: 0.04,
            waitCooldownMs: 400,
            queueDropAt: 50,
            queueKeep: 20
        },
        balanced: {
            startBuffer: 0.25,
            startBehindEdge: 0.10,
            hardSeekDrift: 0.70,
            gentleDrift: 0.25,
            gentleRate: 1.035,
            trimTotalBuffer: 6.5,
            trimBackBuffer: 4.0,
            trimKeepBehind: 3.0,
            waitRecoverDrift: 0.25,
            waitRecoverBehindEdge: 0.06,
            waitCooldownMs: 600,
            queueDropAt: 60,
            queueKeep: 30
        },
        stable: {
            startBuffer: 0.45,
            startBehindEdge: 0.15,
            hardSeekDrift: 1.2,
            gentleDrift: 0.50,
            gentleRate: 1.02,
            trimTotalBuffer: 8.0,
            trimBackBuffer: 5.0,
            trimKeepBehind: 4.0,
            waitRecoverDrift: 0.40,
            waitRecoverBehindEdge: 0.10,
            waitCooldownMs: 800,
            queueDropAt: 80,
            queueKeep: 40
        }
    };

    function currentProfile() {
        return PROFILES[activeProfile] || PROFILES.balanced;
    }

    function updateAdaptiveProfile() {
        if (!sourceBuffer || sourceBuffer.buffered.length === 0) return;
        const edge = sourceBuffer.buffered.end(sourceBuffer.buffered.length - 1);
        const drift = Math.max(0, edge - video.currentTime);
        driftEwma = driftEwma === 0 ? drift : (driftEwma * 0.80 + drift * 0.20);

        let next = activeProfile;
        if (recentWaitingCount >= 4 || driftEwma > 1.5 || bufferQueue.length > 60) {
            next = 'stable';
        } else if (recentWaitingCount >= 2 || driftEwma > 0.8 || bufferQueue.length > 40) {
            next = 'balanced';
        } else if (recentWaitingCount === 0 && driftEwma < 0.35 && bufferQueue.length < 15) {
            next = 'aggressive';
        }

        if (next !== activeProfile) {
            activeProfile = next;
            report('Adaptive profile -> ' + activeProfile + ' (drift=' + driftEwma.toFixed(2) + ', q=' + bufferQueue.length + ', waits=' + recentWaitingCount + ')');
        }
    }

    function showWelcome(imageUrl) {
        stopStream();
        welcomeImg.src = imageUrl;
        welcomeImg.style.display = 'block';
        video.style.display = 'none';
        setStatus(null, false);
    }

    function reinitMSE(initSeg) {
        const nowMs = Date.now();
        if (nowMs - lastReinitMs < REINIT_COOLDOWN_MS) {
            report('reinit skipped (cooldown ' + (REINIT_COOLDOWN_MS - (nowMs - lastReinitMs)) + 'ms remaining)');
            return;
        }
        lastReinitMs = nowMs;
        if (playRetryTimer) { clearInterval(playRetryTimer); playRetryTimer = null; }
        if (mediaSource && mediaSource.readyState === 'open') {
            try { mediaSource.endOfStream(); } catch(e) {}
        }
        mediaSource = null; sourceBuffer = null;
        bufferQueue = []; isAppending = false;
        hasPlayed = false; appendCount = 0; fatalError = false;
        lastTrimMs = 0; lastWaitingRecoveryMs = 0;
        recentWaitingCount = 0; lastControlTickMs = 0; driftEwma = 0.0; activeProfile = 'aggressive';
        playInFlight = false; lastPlayAttemptMs = 0; lastPlayRejectLogMs = 0;
        lastProgressCT = -1;
        initMSE(initSeg);
    }

    function startWebSocketStream(wsUrl) {
        welcomeImg.style.display = 'none';
        video.style.display = 'block';
        report('Connecting to ' + wsUrl);
        setStatus('Connecting...', true);
        stopStream();

        ws = new WebSocket(wsUrl);
        ws.binaryType = 'arraybuffer';

        ws.onopen = () => {
            report('WebSocket connected');
            setStatus('Buffering...', true);
            setTimeout(() => {
                hideStatusIfRendering();
            }, 1200);
        };

        ws.onmessage = (event) => {
            const data = new Uint8Array(event.data);
            if (!initReceived) {
                initReceived = true;
                lastInitSeg = data;
                report('Init segment: ' + data.length + ' bytes');
                initMSE(data);
                return;
            }
            if (data.length > 7 && data[4]===0x66 && data[5]===0x74 && data[6]===0x79 && data[7]===0x70) {
                lastInitSeg = data;
                report('Re-init segment (resolution change): ' + data.length + ' bytes');
                reinitMSE(data);
                return;
            }
            appendToBuffer(data);
        };

        ws.onerror = (e) => {
            report('WS error');
            setStatus('Connection error', true);
        };

        ws.onclose = () => {
            report('WS closed, reconnecting...');
            setTimeout(() => {
                if (ws && ws.readyState === WebSocket.CLOSED) {
                    initReceived = false;
                    startWebSocketStream(wsUrl);
                }
            }, 500);
        };
    }

    function stopStream() {
        if (playRetryTimer) { clearInterval(playRetryTimer); playRetryTimer = null; }
        if (ws) { ws.onclose = null; ws.close(); ws = null; }
        if (mediaSource && mediaSource.readyState === 'open') {
            try { mediaSource.endOfStream(); } catch(e) {}
        }
        mediaSource = null; sourceBuffer = null;
        bufferQueue = []; isAppending = false; initReceived = false;
        hasPlayed = false; appendCount = 0; firstFragmentDTS = -1; fatalError = false;
        lastTrimMs = 0; lastWaitingRecoveryMs = 0;
        recentWaitingCount = 0; lastControlTickMs = 0; driftEwma = 0.0; activeProfile = 'aggressive';
        playInFlight = false; lastPlayAttemptMs = 0; lastPlayRejectLogMs = 0;
        lastProgressCT = -1;
    }

    function initMSE(initSeg) {
        mediaSource = new MediaSource();

        mediaSource.addEventListener('sourceopen', () => {
            report('MSE sourceopen');
            const codec = detectCodec(initSeg) || 'avc1.640029';
            report('Codec: ' + codec);

            try {
                sourceBuffer = mediaSource.addSourceBuffer('video/mp4; codecs="' + codec + '"');
                sourceBuffer.mode = 'sequence';
                report('SourceBuffer created OK (sequence mode)');
            } catch (e) {
                report('addSourceBuffer failed with ' + codec + ': ' + e.message);
                try {
                    sourceBuffer = mediaSource.addSourceBuffer('video/mp4; codecs="avc1.42E01E"');
                    sourceBuffer.mode = 'sequence';
                    report('Fallback SourceBuffer created (Baseline, sequence mode)');
                } catch (e2) {
                    report('Fallback addSourceBuffer also failed: ' + e2.message);
                    return;
                }
            }

            sourceBuffer.addEventListener('updateend', onUpdateEnd);
            sourceBuffer.addEventListener('error', (e) => {
                report('SourceBuffer error event');
                fatalError = true;
                bufferQueue = [];
            });

            bufferQueue.unshift(initSeg);
            drainQueue();

            playRetryTimer = setInterval(() => {
                tryPlay();
                if (sourceBuffer && !hasPlayed) {
                    const bl = sourceBuffer.buffered.length;
                    const vp = video.paused;
                    const ct = video.currentTime.toFixed(2);
                    const re = video.readyState;
                    report('status: buffered=' + bl + ' paused=' + vp + ' time=' + ct + ' readyState=' + re + ' appends=' + appendCount + ' qLen=' + bufferQueue.length);
                }
            }, 500);
        });

        mediaSource.addEventListener('sourceended', () => report('MSE sourceended'));
        mediaSource.addEventListener('sourceclose', () => report('MSE sourceclose'));

        video.src = URL.createObjectURL(mediaSource);
        report('video.src set, waiting for sourceopen...');
    }

    function onUpdateEnd() {
        isAppending = false;
        appendCount++;
        if (appendCount <= 3) {
            const bl = sourceBuffer.buffered.length;
            let info = 'updateend #' + appendCount + ' buffered.length=' + bl;
            if (bl > 0) {
                info += ' range=[' + sourceBuffer.buffered.start(0).toFixed(3) + ',' + sourceBuffer.buffered.end(0).toFixed(3) + ']';
            }
            report(info);
        }
        if (sourceBuffer && sourceBuffer.buffered.length > 0) {
            setStatus(null, false);
        }
        drainQueue();
        tryPlay();
    }

    function appendToBuffer(data) {
        const profile = currentProfile();
        if (bufferQueue.length > profile.queueDropAt) {
            let dropped = 0;
            const keep = [];
            for (let i = bufferQueue.length - profile.queueKeep; i < bufferQueue.length; i++) {
                if (i >= 0) keep.push(bufferQueue[i]);
            }
            dropped = bufferQueue.length - keep.length;
            bufferQueue = keep;
            if (dropped > 0) report('Dropped ' + dropped + ' queued fragments (queue overflow)');
        }
        bufferQueue.push(data);
        drainQueue();
    }

    function drainQueue() {
        if (fatalError || isAppending || !sourceBuffer || bufferQueue.length === 0) return;
        if (sourceBuffer.updating) return;
        isAppending = true;
        const chunk = bufferQueue.shift();
        try {
            sourceBuffer.appendBuffer(chunk);
        } catch (e) {
            report('appendBuffer error: ' + e.name + ' ' + e.message);
            isAppending = false;
            if (e.name === 'QuotaExceededError' && sourceBuffer.buffered.length > 0) {
                try {
                    sourceBuffer.remove(0, sourceBuffer.buffered.end(0) - 1);
                } catch(re) {}
            }
        }
    }

    function requestPlay(reason) {
        const nowMs = Date.now();
        if (playInFlight) return;
        if (!video.paused) return;
        if (nowMs - lastPlayAttemptMs < 150) return;

        lastPlayAttemptMs = nowMs;
        playInFlight = true;

        video.play().then(() => {
            playInFlight = false;
            if (!hasPlayed) {
                hasPlayed = true;
                report('PLAYING! time=' + video.currentTime.toFixed(2));
                setStatus(null, false);
                if (playRetryTimer) { clearInterval(playRetryTimer); playRetryTimer = null; }
            }
        }).catch((e) => {
            playInFlight = false;
            if (e && e.name === 'AbortError') {
                if (nowMs - lastPlayRejectLogMs > 2000) {
                    lastPlayRejectLogMs = nowMs;
                    report('play() rejected (AbortError) during ' + reason);
                }
                return;
            }
            report('play() rejected: ' + (e ? e.name : 'Error') + ' ' + (e && e.message ? e.message : ''));
        });
    }

    function tryPlay() {
        if (!sourceBuffer) return;
        const profile = currentProfile();
        if (video.paused && sourceBuffer.buffered.length > 0) {
            const start = sourceBuffer.buffered.start(0);
            const edge = sourceBuffer.buffered.end(sourceBuffer.buffered.length - 1);
            const bufferedAhead = edge - start;
            if (bufferedAhead < profile.startBuffer) return;
            video.currentTime = Math.max(0, edge - profile.startBehindEdge);
            requestPlay('tryPlay');
        }
        if (!video.paused && sourceBuffer && !sourceBuffer.updating && sourceBuffer.buffered.length > 0) {
            const nowMs = Date.now();
            const start = sourceBuffer.buffered.start(0);
            const edge = sourceBuffer.buffered.end(sourceBuffer.buffered.length - 1);
            const backBuffer = video.currentTime - start;
            const totalBuffered = edge - start;

            if (totalBuffered > profile.trimTotalBuffer && backBuffer > profile.trimBackBuffer && nowMs - lastTrimMs > 1800) {
                const trimEnd = video.currentTime - profile.trimKeepBehind;
                if (trimEnd > start) {
                    try {
                        sourceBuffer.remove(start, trimEnd);
                        lastTrimMs = nowMs;
                    } catch(e) {}
                }
            }
        }
    }

    setInterval(() => {
        if (!sourceBuffer || sourceBuffer.buffered.length === 0 || video.paused) return;
        const nowMs = Date.now();
        if (nowMs - lastControlTickMs > 600) {
            lastControlTickMs = nowMs;
            updateAdaptiveProfile();
        }

        if (sourceBuffer.buffered.length > 5 && lastInitSeg) {
            report('Fragmented buffer (' + sourceBuffer.buffered.length + ' ranges) — reinit');
            reinitMSE(lastInitSeg);
            return;
        }

        const ct = video.currentTime;
        if (lastProgressCT >= 0 && Math.abs(ct - lastProgressCT) < 0.01) {
            if (nowMs - lastProgressTime > 4000 && lastInitSeg) {
                report('Stall detected (' + ct.toFixed(2) + 's for 4s) — reinit');
                lastProgressCT = -1;
                reinitMSE(lastInitSeg);
                return;
            }
        } else {
            lastProgressTime = nowMs;
            lastProgressCT = ct;
        }

        const profile = currentProfile();
        const edge = sourceBuffer.buffered.end(sourceBuffer.buffered.length - 1);
        const drift = edge - video.currentTime;
        if (drift > profile.hardSeekDrift) {
            video.currentTime = edge - profile.startBehindEdge;
            video.playbackRate = 1.0;
        } else if (drift > profile.gentleDrift) {
            const queueBoost = bufferQueue.length > 25 ? 0.015 : 0.0;
            video.playbackRate = Math.min(1.08, profile.gentleRate + queueBoost);
        } else {
            video.playbackRate = 1.0;
        }
    }, 150);

    video.addEventListener('error', (e) => {
        const err = video.error;
        report('video error: code=' + (err ? err.code : '?') + ' msg=' + (err ? err.message : '?'));
        if (lastInitSeg) {
            report('Video error — reinit MSE');
            fatalError = false;
            setTimeout(() => reinitMSE(lastInitSeg), 500);
        } else {
            fatalError = true;
            bufferQueue = [];
        }
    });
    video.addEventListener('waiting', () => {
        if (!hasPlayed) return;
        const profile = currentProfile();
        const nowMs = Date.now();
        if (nowMs - lastWaitingRecoveryMs < profile.waitCooldownMs) return;
        lastWaitingRecoveryMs = nowMs;

        recentWaitingCount += 1;
        setTimeout(() => {
            recentWaitingCount = Math.max(0, recentWaitingCount - 1);
        }, 4500);

        report('video waiting');
        if (sourceBuffer && sourceBuffer.buffered.length > 0) {
            const edge = sourceBuffer.buffered.end(sourceBuffer.buffered.length - 1);
            if (edge - video.currentTime > profile.waitRecoverDrift) {
                video.currentTime = edge - profile.waitRecoverBehindEdge;
                requestPlay('waiting');
                report('waiting recovery: seek to ' + video.currentTime.toFixed(3));
            }
        }
    });
    video.addEventListener('playing', () => {
        playInFlight = false;
        setStatus(null, false);
    });
    video.addEventListener('timeupdate', () => {
        hideStatusIfRendering();
    });
    video.addEventListener('canplay', () => {
        hideStatusIfRendering();
    });
    video.addEventListener('loadeddata', () => {
        hideStatusIfRendering();
    });
    video.addEventListener('stalled', () => {
        report('video stalled bl=' + (sourceBuffer ? sourceBuffer.buffered.length : 0));
        if (sourceBuffer && sourceBuffer.buffered.length > 0) {
            const edge = sourceBuffer.buffered.end(sourceBuffer.buffered.length - 1);
            if (edge - video.currentTime > 0.2) {
                video.currentTime = edge - 0.02;
            }
        }
    });
    setInterval(() => {
        if (video.currentTime > 0.2 && !video.paused) {
            setStatus(null, false);
        }
    }, 1000);

    function detectCodec(d) {
        for (let i = 0; i < d.length - 8; i++) {
            if (d[i]===0x61 && d[i+1]===0x76 && d[i+2]===0x63 && d[i+3]===0x43) {
                if (d[i+4] === 1 && i+7 < d.length) {
                    const h = n => n.toString(16).padStart(2,'0');
                    return 'avc1.' + h(d[i+5]) + h(d[i+6]) + h(d[i+7]);
                }
            }
        }
        return null;
    }
    </script>
</body>
</html>
