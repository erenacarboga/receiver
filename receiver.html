<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
    <style>
        html, body {
            margin: 0; padding: 0;
            width: 100%; height: 100%;
            background: #000; overflow: hidden;
        }
        video { width: 100%; height: 100%; object-fit: contain; background: #000; }
        #welcome-img {
            display: none;
            position: fixed; top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: contain;
            background: #000;
            z-index: 5;
        }
        #status {
            position: fixed; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: #fff; font: 24px -apple-system, sans-serif;
            text-align: center; opacity: 0.8;
            transition: opacity 0.5s;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="status">Waiting for stream...</div>
    <img id="welcome-img" />
    <video id="v" autoplay muted playsinline></video>
    <script>
    const TAG = '[SMReceiver]';
    const NS = 'urn:x-cast:com.screenmirror.stream';
    const statusEl = document.getElementById('status');
    const video = document.getElementById('v');
    const welcomeImg = document.getElementById('welcome-img');

    const ctx = cast.framework.CastReceiverContext.getInstance();
    const pm = ctx.getPlayerManager();
    let senderBusId = null;

    function report(msg) {
        console.log(TAG, msg);
        if (senderBusId) {
            try {
                ctx.sendCustomMessage(NS, senderBusId, {type: 'DIAG', msg: msg});
            } catch(e) {}
        }
    }

    ctx.addCustomMessageListener(NS, event => {
        senderBusId = event.senderId;
        console.log(TAG, 'Custom message from', event.senderId, ':', JSON.stringify(event.data));
        if (event.data.type === 'START_STREAM') {
            report('START_STREAM received: ' + event.data.wsUrl);
            startWebSocketStream(event.data.wsUrl);
        } else if (event.data.type === 'STOP_STREAM') {
            stopStream();
        } else if (event.data.type === 'SHOW_WELCOME') {
            report('SHOW_WELCOME: ' + event.data.imageUrl);
            showWelcome(event.data.imageUrl);
        }
    });

    pm.setMessageInterceptor(
        cast.framework.messages.MessageType.LOAD,
        loadRequest => {
            try {
                const hlsUrl = loadRequest.media.contentId;
                report('LOAD intercepted: ' + hlsUrl);
                const url = new URL(hlsUrl);
                const wsUrl = 'ws://' + url.hostname + ':8082/stream';
                startWebSocketStream(wsUrl);
            } catch (e) {
                report('LOAD intercept error: ' + e.message);
            }
            return null;
        }
    );

    const opts = new cast.framework.CastReceiverOptions();
    opts.disableIdleTimeout = true;
    opts.statusText = '';
    opts.customNamespaces = {};
    opts.customNamespaces[NS] = cast.framework.system.MessageType.JSON;
    ctx.start(opts);
    console.log(TAG, 'Receiver v2 started');

    let ws = null, mediaSource = null, sourceBuffer = null;
    let bufferQueue = [], isAppending = false, initReceived = false;
    let hasPlayed = false, appendCount = 0, firstFragmentDTS = -1;
    let playRetryTimer = null, fatalError = false;
    let seekCooldownMs = 700;
    let minLiveOffset = 0.10;
    let maxLiveOffset = 0.45;
    let stableLiveOffset = 0.18;
    let congestedLiveOffset = 0.30;
    let congestedQueueThreshold = 18;
    let waitingRecoveryThreshold = 0.45;
    let hardSeekThreshold = 1.6;
    let softCatchupThreshold = 0.7;
    let softCatchupRate = 1.02;
    let normalRate = 1.0;
    let seekLead = 0.12;
    let trimBehindSeconds = 3.0;
    let catchupIntervalMs = 300;
    let waitingSeekBackoffMs = 1200;
    let waitingSpikeWindowMs = 8000;
    let waitingSpikeCountForCongestion = 3;
    let queueSpikeForCongestion = 25;
    let startedAtMs = Date.now();
    let warmupDurationMs = 6000;
    let waitingEvents = [];
    let recentWaitings = [];
    let seekState = { lastSeekAt: 0, lastWaitingSeekAt: 0 };

    function nowMs() { return Date.now(); }

    function canSeek() {
        return (nowMs() - seekState.lastSeekAt) >= seekCooldownMs;
    }

    function recordSeek() {
        seekState.lastSeekAt = nowMs();
    }

    function recordWaitingEvent() {
        const t = nowMs();
        recentWaitings.push(t);
        while (recentWaitings.length > 0 && (t - recentWaitings[0]) > waitingSpikeWindowMs) {
            recentWaitings.shift();
        }
    }

    function isCongested() {
        return bufferQueue.length >= queueSpikeForCongestion || recentWaitings.length >= waitingSpikeCountForCongestion;
    }

    function liveOffsetTarget() {
        const inWarmup = (nowMs() - startedAtMs) < warmupDurationMs;
        const base = (inWarmup || isCongested() || bufferQueue.length >= congestedQueueThreshold)
            ? congestedLiveOffset
            : stableLiveOffset;
        return Math.min(maxLiveOffset, Math.max(minLiveOffset, base));
    }

    function showWelcome(imageUrl) {
        stopStream();
        welcomeImg.src = imageUrl;
        welcomeImg.style.display = 'block';
        video.style.display = 'none';
        statusEl.style.opacity = '0';
    }

    function reinitMSE(initSeg) {
        if (playRetryTimer) { clearInterval(playRetryTimer); playRetryTimer = null; }
        if (mediaSource && mediaSource.readyState === 'open') {
            try { mediaSource.endOfStream(); } catch(e) {}
        }
        mediaSource = null; sourceBuffer = null;
        bufferQueue = []; isAppending = false;
        hasPlayed = false; appendCount = 0; fatalError = false;
        initMSE(initSeg);
    }

    function startWebSocketStream(wsUrl) {
        welcomeImg.style.display = 'none';
        video.style.display = 'block';
        report('Connecting to ' + wsUrl);
        statusEl.textContent = 'Connecting...';
        statusEl.style.opacity = '0.8';
        stopStream();

        ws = new WebSocket(wsUrl);
        ws.binaryType = 'arraybuffer';

        ws.onopen = () => {
            report('WebSocket connected');
            statusEl.textContent = 'Buffering...';
        };

        ws.onmessage = (event) => {
            const data = new Uint8Array(event.data);
            if (!initReceived) {
                initReceived = true;
                report('Init segment: ' + data.length + ' bytes');
                initMSE(data);
                return;
            }
            if (data.length > 7 && data[4]===0x66 && data[5]===0x74 && data[6]===0x79 && data[7]===0x70) {
                report('Re-init segment (resolution change): ' + data.length + ' bytes');
                reinitMSE(data);
                return;
            }
            appendToBuffer(data);
        };

        ws.onerror = (e) => {
            report('WS error');
            statusEl.textContent = 'Connection error';
            statusEl.style.opacity = '0.8';
        };

        ws.onclose = () => {
            report('WS closed, reconnecting...');
            setTimeout(() => {
                if (ws && ws.readyState === WebSocket.CLOSED) {
                    initReceived = false;
                    startWebSocketStream(wsUrl);
                }
            }, 1000);
        };
    }

    function stopStream() {
        if (playRetryTimer) { clearInterval(playRetryTimer); playRetryTimer = null; }
        if (ws) { ws.onclose = null; ws.close(); ws = null; }
        if (mediaSource && mediaSource.readyState === 'open') {
            try { mediaSource.endOfStream(); } catch(e) {}
        }
        mediaSource = null; sourceBuffer = null;
        bufferQueue = []; isAppending = false; initReceived = false;
        hasPlayed = false; appendCount = 0; firstFragmentDTS = -1; fatalError = false;
    }

    function initMSE(initSeg) {
        mediaSource = new MediaSource();

        mediaSource.addEventListener('sourceopen', () => {
            report('MSE sourceopen');
            const codec = detectCodec(initSeg) || 'avc1.640029';
            report('Codec: ' + codec);

            try {
                sourceBuffer = mediaSource.addSourceBuffer('video/mp4; codecs="' + codec + '"');
                report('SourceBuffer created OK');
            } catch (e) {
                report('addSourceBuffer failed with ' + codec + ': ' + e.message);
                try {
                    sourceBuffer = mediaSource.addSourceBuffer('video/mp4; codecs="avc1.42E01E"');
                    report('Fallback SourceBuffer created (Baseline)');
                } catch (e2) {
                    report('Fallback addSourceBuffer also failed: ' + e2.message);
                    return;
                }
            }

            sourceBuffer.addEventListener('updateend', onUpdateEnd);
            sourceBuffer.addEventListener('error', (e) => {
                report('SourceBuffer error event');
                fatalError = true;
                bufferQueue = [];
            });

            bufferQueue.unshift(initSeg);
            drainQueue();

            playRetryTimer = setInterval(() => {
                tryPlay();
                if (sourceBuffer && !hasPlayed) {
                    const bl = sourceBuffer.buffered.length;
                    const vp = video.paused;
                    const ct = video.currentTime.toFixed(2);
                    const re = video.readyState;
                    report('status: buffered=' + bl + ' paused=' + vp + ' time=' + ct + ' readyState=' + re + ' appends=' + appendCount + ' qLen=' + bufferQueue.length);
                }
            }, 1000);
        });

        mediaSource.addEventListener('sourceended', () => report('MSE sourceended'));
        mediaSource.addEventListener('sourceclose', () => report('MSE sourceclose'));

        video.src = URL.createObjectURL(mediaSource);
        report('video.src set, waiting for sourceopen...');
    }

    function onUpdateEnd() {
        isAppending = false;
        appendCount++;
        if (appendCount <= 3) {
            const bl = sourceBuffer.buffered.length;
            let info = 'updateend #' + appendCount + ' buffered.length=' + bl;
            if (bl > 0) {
                info += ' range=[' + sourceBuffer.buffered.start(0).toFixed(3) + ',' + sourceBuffer.buffered.end(0).toFixed(3) + ']';
            }
            report(info);
        }
        drainQueue();
        tryPlay();
    }

    function appendToBuffer(data) {
        if (bufferQueue.length > 90) {
            let dropped = 0;
            const keep = [];
            for (let i = bufferQueue.length - 45; i < bufferQueue.length; i++) {
                if (i >= 0) keep.push(bufferQueue[i]);
            }
            dropped = bufferQueue.length - keep.length;
            bufferQueue = keep;
            if (dropped > 0) report('Dropped ' + dropped + ' queued fragments (queue overflow)');
        }
        bufferQueue.push(data);
        drainQueue();
    }

    function drainQueue() {
        if (fatalError || isAppending || !sourceBuffer || bufferQueue.length === 0) return;
        if (sourceBuffer.updating) return;
        isAppending = true;
        const chunk = bufferQueue.shift();
        try {
            sourceBuffer.appendBuffer(chunk);
        } catch (e) {
            report('appendBuffer error: ' + e.name + ' ' + e.message);
            isAppending = false;
            if (e.name === 'QuotaExceededError' && sourceBuffer.buffered.length > 0) {
                try {
                    sourceBuffer.remove(0, sourceBuffer.buffered.end(0) - 1);
                } catch(re) {}
            }
        }
    }

    function tryPlay() {
        if (!sourceBuffer) return;
        if (video.paused && sourceBuffer.buffered.length > 0) {
            const edge = sourceBuffer.buffered.end(sourceBuffer.buffered.length - 1);
            const target = liveOffsetTarget();
            video.currentTime = Math.max(0, edge - target);
            video.play().then(() => {
                if (!hasPlayed) {
                    hasPlayed = true;
                    report('PLAYING! time=' + video.currentTime.toFixed(2));
                    statusEl.style.opacity = '0';
                    if (playRetryTimer) { clearInterval(playRetryTimer); playRetryTimer = null; }
                }
            }).catch((e) => {
                report('play() rejected: ' + e.name + ' ' + e.message);
            });
        }
        if (!video.paused && sourceBuffer && !sourceBuffer.updating && sourceBuffer.buffered.length > 0) {
            const trimEnd = video.currentTime - trimBehindSeconds;
            if (trimEnd > sourceBuffer.buffered.start(0)) {
                try { sourceBuffer.remove(sourceBuffer.buffered.start(0), trimEnd); } catch(e) {}
            }
        }
    }

    setInterval(() => {
        if (!sourceBuffer || sourceBuffer.buffered.length === 0 || video.paused) return;
        const edge = sourceBuffer.buffered.end(sourceBuffer.buffered.length - 1);
        const drift = edge - video.currentTime;
        const target = liveOffsetTarget();
        if (drift > hardSeekThreshold && canSeek()) {
            video.currentTime = Math.max(0, edge - Math.max(target, seekLead));
            recordSeek();
            video.playbackRate = normalRate;
        } else if (drift > softCatchupThreshold) {
            video.playbackRate = softCatchupRate;
        } else {
            video.playbackRate = normalRate;
        }
    }, catchupIntervalMs);

    video.addEventListener('error', (e) => {
        const err = video.error;
        report('video error: code=' + (err ? err.code : '?') + ' msg=' + (err ? err.message : '?'));
        fatalError = true;
        bufferQueue = [];
    });
    video.addEventListener('waiting', () => {
        if (!hasPlayed) return;
        report('video waiting');
        recordWaitingEvent();
        if (sourceBuffer && sourceBuffer.buffered.length > 0) {
            const edge = sourceBuffer.buffered.end(sourceBuffer.buffered.length - 1);
            const drift = edge - video.currentTime;
            const t = nowMs();
            const waitingSeekAllowed = (t - seekState.lastWaitingSeekAt) >= waitingSeekBackoffMs;
            if (drift > waitingRecoveryThreshold && waitingSeekAllowed && canSeek()) {
                const target = liveOffsetTarget();
                video.currentTime = Math.max(0, edge - Math.max(target, 0.10));
                seekState.lastWaitingSeekAt = t;
                recordSeek();
                video.play().catch(() => {});
                report('waiting recovery: seek to ' + video.currentTime.toFixed(3));
            }
        }
    });
    video.addEventListener('stalled', () => report('video stalled'));

    function detectCodec(d) {
        for (let i = 0; i < d.length - 8; i++) {
            if (d[i]===0x61 && d[i+1]===0x76 && d[i+2]===0x63 && d[i+3]===0x43) {
                if (d[i+4] === 1 && i+7 < d.length) {
                    const h = n => n.toString(16).padStart(2,'0');
                    return 'avc1.' + h(d[i+5]) + h(d[i+6]) + h(d[i+7]);
                }
            }
        }
        return null;
    }
    </script>
</body>
</html>
